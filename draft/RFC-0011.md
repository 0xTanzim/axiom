# RFC-0011: Axiom Persistence & Transaction System (DX-First)

**Status:** Draft
**Priority:** P0 (Adoption Critical)
**Target Java:** 21+ (25 LTS compatible)
**Audience:** Java backend developers
**Scope:** Persistence, Transactions, AOP
**Does NOT affect:** Routing, Handlers, Middleware DX

---

## 1. Motivation

Axiom is a **Java framework**.

Modern Java developers expect:

* ORM support (JPA / Hibernate)
* `@Transactional`
* Clean repositories and services
* No database bootstrapping noise
* Ability to mix ORM + SQL when needed
* Familiar annotations **without Spring**

If these expectations are not met, users will feel friction and leave.

This RFC introduces **full persistence support with clean, predictable magic**, without turning Axiom into Spring.

---

## 2. Core Principle (FROZEN)

> **Axiom provides infrastructure magic, not application magic.**

* HTTP flow remains explicit
* Routing remains explicit
* Persistence, transactions, lifecycle are automatic and boring

This keeps control where it matters and removes hassle where it doesn’t.

---

## 3. User-Facing Mental Model (IMPORTANT)

From the user’s point of view, there is **ONE persistence system**:

```text
axiom-persistence
```

Users do **not** think about:

* tx vs orm vs jooq vs jdbc
* aop engines
* lifecycle hooks

They just use persistence.

---

## 4. Supported Persistence Styles (ALL FIRST-CLASS)

Axiom **fully supports all three styles**, simultaneously.

| Style               | Purpose                 | Status        |
| ------------------- | ----------------------- | ------------- |
| **JPA / Hibernate** | Default, domain-centric | ✅ Primary     |
| **jOOQ**            | Complex SQL, reports    | ✅ First-class |
| **JDBC**            | Hot paths, low-level    | ✅ First-class |

Users may:

* Use only one
* Mix all three in the same transaction

---

## 5. Module Structure (Internal vs External)

### 5.1 What USERS see

```text
axiom-persistence
```

Single dependency. No confusion.

---

### 5.2 What MAINTAINERS implement (internal)

```text
axiom-persistence/
 ├── tx/        (transaction engine)
 ├── aop/       (compile-time AOP)
 ├── jpa/       (JPA / Hibernate integration)
 ├── jooq/      (jOOQ integration)
 └── jdbc/      (JDBC helpers)
```

This separation is **internal only**.

---

## 6. Startup DX (Zero Noise)

### User code

```java
AxiomPersistence.start();
```

That’s it.

### What happens internally

* DataSource is created
* Transaction engine is initialized
* If JPA present → EntityManagerFactory booted
* If jOOQ present → DSLContext created
* Lifecycle hooks registered

No extra configuration code required.

---

## 7. ORM Support (JPA / Hibernate)

ORM is the **default and recommended** persistence style.

### 7.1 EntityManager Access — BOTH DX SUPPORTED

Axiom **intentionally supports both styles**.

#### Option A: Standard JPA DX (familiar, clean)

```java
public class UserRepository {

    @PersistenceContext
    private EntityManager em;

    public User find(String id) {
        return em.find(User.class, id);
    }
}
```

* Standard JPA annotation
* Familiar to Java developers
* Works without Spring

---

#### Option B: Explicit Axiom DX (framework-style)

```java
public class UserRepository {

    private final EntityManager em = Jpa.em();

    public User find(String id) {
        return em.find(User.class, id);
    }
}
```

* Explicit
* No annotations
* Easy to reason about
* Request-scoped `EntityManager`

Both options:

* Use the same underlying `EntityManager`
* Participate in the same transaction
* Are safe and supported

---

## 8. Transaction System (`@Transactional`)

### 8.1 Annotation-Driven Transactions (MANDATORY)

```java
@Transactional
public void createUser(CreateUser cmd) {
    userRepo.save(cmd.toEntity());
    auditRepo.log("USER_CREATED");
}
```

### 8.2 Semantics (Clear & Predictable)

* Transaction begins at method entry
* Commit on normal return
* Rollback on unchecked exception
* Nested calls reuse the same transaction
* Works across ORM, jOOQ, JDBC

---

### 8.3 Execution Model

* One HTTP request = one virtual thread
* One transaction bound to that thread
* No leaking across requests
* No runtime proxies

AOP is **compile-time or build-time only**.

---

## 9. jOOQ Support

### Usage

```java
@Transactional
public List<Order> loadOrders(String userId) {
    return Jooq.dsl()
        .selectFrom(ORDERS)
        .where(ORDERS.USER_ID.eq(userId))
        .fetchInto(Order.class);
}
```

* Uses same DataSource
* Uses same transaction
* Uses same DB connection

---

## 10. JDBC Support

### Usage (optional, power users)

```java
public int countActiveUsers() {
    return Jdbc.queryInt(
        "SELECT COUNT(*) FROM users WHERE active = true"
    );
}
```

* No connection handling
* No lifecycle code
* Same transaction if active

---

## 11. Mixing ORM + jOOQ + JDBC (KEY FEATURE)

Fully supported and encouraged.

```java
@Transactional
public UserProfile loadProfile(String id) {

    User user = Jpa.em().find(User.class, id);

    List<Order> orders = Jooq.dsl()
        .selectFrom(ORDERS)
        .where(ORDERS.USER_ID.eq(id))
        .fetchInto(Order.class);

    int loginCount = Jdbc.queryInt(
        "SELECT COUNT(*) FROM logins WHERE user_id = ?", id
    );

    return new UserProfile(user, orders, loginCount);
}
```

Guarantees:

* One transaction
* One connection
* Zero confusion

---

## 12. DTO Rules (NO CONFUSION)

> **DTOs exist ONLY at the HTTP boundary.**

* Request DTO → `ctx.body(...)`
* Response DTO → `ctx.json(...)`
* DTOs never enter repositories or ORM

Example:

```java
CreateUserRequest req = ctx.body(CreateUserRequest.class);
userService.create(req);
```

---

## 13. Lombok Policy

* Fully supported
* Officially recommended
* Axiom does not interfere

---

## 14. Error Handling Integration

* Rollback occurs before error handler
* Errors propagate normally
* No swallowed exceptions
* No implicit retries

---

## 15. Performance Guarantees

| Area          | Guarantee               |
| ------------- | ----------------------- |
| HTTP hot path | Zero reflection         |
| ORM           | Native performance      |
| Transactions  | O(1) overhead           |
| AOP           | Compile/build-time only |
| SQL           | Pooled connections      |

---

## 16. Why This Is NOT Spring

| Spring           | Axiom                  |
| ---------------- | ---------------------- |
| Runtime proxies  | Compile-time AOP       |
| Container-driven | App-driven             |
| Hidden routing   | Explicit routing       |
| Heavy reflection | No hot-path reflection |

Same Java UX.
Cleaner architecture.

---

## 17. Final Principle (LOCKED)

> **Axiom persistence is boring, predictable, and powerful —
> ORM by default, SQL when needed, magic only where expected.**
