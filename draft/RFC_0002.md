
# RFC — Axiom Routing & Application Composition

**Status:** Draft
**Last Updated:** 2026
**Target Java Version:** **25 LTS** (min 21)
**Audience:** Backend engineers, framework contributors

---

## 1. Problem Statement

As applications grow to **100–500+ routes**, routing APIs must remain:

* Readable
* Explicit
* Easy to scale
* Free of registration boilerplate
* Free of reflection and annotation scanning

Many Java frameworks fail here by:

* Forcing annotations
* Hiding routes behind classpath scanning
* Requiring global registries
* Making route composition noisy

**Axiom’s goal** is to provide an **Express / Hono–like routing experience in Java**, without fighting the language or enforcing framework patterns.

---

## 2. Design Goals

1. **DX-first**: routing should read like intent, not mechanics
2. **Explicit composition**: no auto-discovery, no scanning
3. **Zero forced patterns**: no required interfaces, inheritance, or overrides
4. **Scales naturally**: works for 5 routes or 500 routes
5. **Java-native**: no syntax tricks that fight the language
6. **Router ownership**: each feature owns its own router
7. **Composable**: routers can be mounted, grouped, and merged

---

## 3. Core Idea

> **A Router is the unit of composition.
> Route files return Routers.
> The App mounts Routers.**

No annotations.
No interfaces.
No lifecycle contracts.

Just code.

---

## 4. Router Creation Model

### 4.1 Router is created by user code

```java
Router r = new Router();
```

The framework **never forces**:

* `implements`
* `@Override`
* base classes
* factories

Users are free to create routers however they want.

---

### 4.2 Route files expose routers via functions

A route file is simply a **plain Java class** that provides a router.

#### Example: `UserRoutes.java`

```java
public final class UserRoutes {

    public static Router router() {
        Router r = new Router();

        r.get("/", c -> c.json(listUsers()));
        r.get("/:id", c -> c.json(findUser(c.param("id"))));
        r.post("/", c -> c.json(createUser(c.body(UserCreate.class))));

        r.group("/roles", rr -> {
            rr.get("/", c -> c.json(listRoles()));
            rr.post("/", c -> c.json(createRole()));
        });

        return r;
    }
}
```

Key points:

* No framework interfaces
* No required method names (only convention)
* Full freedom inside the router
* Sub-groups allowed

---

## 5. App Routing API

### 5.1 App mounts routers, it does not register routes

```java
public final class App {

    public void route(Router router);

    public void route(String basePath, Router router);

    public void route(Supplier<Router> router);

    public void route(String basePath, Supplier<Router> router);
}
```

This allows **maximum flexibility** with minimal surface area.

---

### 5.2 Canonical usage (recommended)

```java
App app = new App();

app.route(UserRoutes::router);
app.route("/admin", AdminUserRoutes::router);
app.route("/health", HealthRoutes::router);

app.listen();
```

This achieves:

* No `.class`
* No `.routes()`
* No `new` in user land
* Clean, expressive DX

---

## 6. Why `Supplier<Router>` is the Chosen Model

Passing a `Supplier<Router>`:

* Avoids reflection
* Avoids forced interfaces
* Allows future dependency injection
* Keeps Router creation fully user-controlled
* Matches Java’s functional style

Example inline usage is also supported:

```java
app.route(() -> {
    Router r = new Router();
    r.get("/ping", c -> c.text("pong"));
    return r;
});
```

---

## 7. Router Mounting Semantics

When mounting a router with a base path:

```java
app.route("/admin", AdminRoutes::router);
```

Axiom must:

1. Create the router via the supplier
2. Prefix all routes with `/admin`
3. Merge routes into the root router
4. Detect conflicts (same method + same path)

This happens **once at startup**, never in request hot paths.

---

## 8. Router Grouping (Intra-Router Composition)

Routers support grouping to avoid file explosion.

```java
r.group("/admin", admin -> {
    admin.get("/stats", ...);
    admin.get("/users", ...);
});
```

Grouping rules:

* Groups only affect path prefixing
* Groups do not create new routers
* Groups are compile-time composition

---

## 9. Folder-Based Organization (Recommended)

Large applications should organize routes by domain.

```
routes/
 ├─ users/
 │   └─ UserRoutes.java
 ├─ admin/
 │   ├─ AdminUserRoutes.java
 │   └─ AdminOrderRoutes.java
 ├─ health/
 │   └─ HealthRoutes.java
```

Each file:

* Owns its domain
* Exposes a router
* Is mounted explicitly by the App

---

## 10. Explicit Non-Goals

Routing in Axiom will **not** include:

* Annotation-based controllers
* Classpath scanning
* Auto-registration
* XML/YAML route definitions
* Global mutable registries

All routes are defined **in code, explicitly**.

---

## 11. Benefits of This Model

* Scales to hundreds of route files
* No central “registration hell”
* Clear ownership and boundaries
* Easy refactoring and grepability
* Testable without App or Server
* Zero runtime magic

---

## 12. Testing Philosophy

Routers are testable in isolation.

```java
Router r = UserRoutes.router();

assertTrue(r.hasRoute("GET", "/:id"));
```

No server.
No container.
No mocks.

---

## 13. Final Decision (Locked)

* Routers are created by user code
* Route files expose routers via functions
* App mounts routers explicitly
* `Supplier<Router>` is the preferred DX
* No forced interfaces or inheritance
* No `.class`, no annotations, no scanning

---

## 14. Summary

This routing model:

* Matches Express / Hono DX
* Respects Java’s language rules
* Avoids Spring-style complexity
* Stays explicit and debuggable
* Scales from small apps to large systems

**Axiom routing is simple by default, powerful by composition.**
