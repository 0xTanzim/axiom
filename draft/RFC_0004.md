## Middleware Pipeline Internals

**Status:** Draft

**Depends on:** RFC-0001

**Priority:** Critical (execution model)

---

## 1. Problem Statement

Middleware must:

- Be easy to write
- Be predictable
- Not hide control flow
- Not require inheritance or annotations

Most Java frameworks fail here.

---

## 2. DX Requirement (Non-Negotiable)

User writes:

```java
app.use((c, next) -> {
    log(c.path());
    next.run();
});

```

This must:

- Execute in order
- Be composable
- Be safe with virtual threads

---

## 3. Public Middleware API

```java
@FunctionalInterface
public interface MiddlewareHandler {
    void handle(Context c, Next next) throws Exception;
}

@FunctionalInterface
public interface Next {
    void run() throws Exception;
}

```

This is the **only API users see**.

---

## 4. Internal Functional Core

Internally, middleware is represented as:

```java
@FunctionalInterface
interface Middleware {
    Handler apply(Handler next);
}

```

This enables **pure function composition**.

---

## 5. Adapting Public DX → Core Model

Each user middleware is adapted like this:

```java
Middleware adapt(MiddlewareHandler m) {
    return nextHandler ->
        c -> m.handle(c, () -> nextHandler.handle(c));
}

```

This preserves:

- Clean DX
- Functional pipeline
- Explicit control flow

---

## 6. Pipeline Construction (Once)

When app starts:

```java
Handler finalHandler = routeHandler;

for (Middleware m : reverse(middlewares)) {
    finalHandler = m.apply(finalHandler);
}

```

Result:

- One composed handler
- No per-request pipeline building
- Zero runtime overhead

---

## 7. Execution Flow (Request Time)

```
Request
 ↓
Middleware 1
 ↓
Middleware 2
 ↓
Middleware 3
 ↓
Route Handler
 ↓
Response

```

If middleware **does not call `next.run()`**, the chain stops.

This enables:

- Auth guards
- Short-circuiting
- Error interception

---

## 8. Error Propagation

If any middleware or handler throws:

```java
Exception → Global Error Handler

```

No middleware needs try/catch.

---

## 9. Example: Auth Middleware

```java
app.use((c, next) -> {
    if (c.state("user").isEmpty()) {
        c.status(401);
        c.text("Unauthorized");
        return;
    }
    next.run();
});

```

Simple. Explicit. Predictable.

---

## 10. Example: Timing Middleware

```java
app.use((c, next) -> {
    long start = System.nanoTime();
    next.run();
    System.out.println(System.nanoTime() - start);
});

```

No magic.

No hooks.

No annotations.

---

## 11. Threading & Safety

- Each request runs on its own virtual thread
- Middleware stack is immutable
- No shared mutable state
- Safe by construction

---

## 12. Performance Characteristics

- Zero allocations per request (after startup)
- No reflection
- No lambdas created at runtime
- Flat call stack

---

## 13. Debugging Support

Optional debug mode:

```java
app.debugMiddleware();

```

Outputs:

```
[0] logging
[1] auth
[2] timing

```

Execution order is explicit.

---

## 14. Final Decision

- Express-style DX
- Functional core
- Immutable pipeline
- Explicit flow
- Java-21 friendly

**Approved for implementation.**Final mentor note

---
