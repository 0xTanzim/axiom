# RFC-0010: Testing Utilities API

**Status:** Draft
**Type:** Testing
**Priority:** Medium
**Depends on:** RFC-0001, RFC-0009

---

## 1. Problem Statement

Testing web frameworks typically requires:

- Starting a real server
- Making HTTP requests
- Parsing responses
- Cleaning up

This is slow and complex.

Axiom should enable:

- Handler testing without server
- Fast unit tests
- Clear assertions
- Integration test support

---

## 2. Design Goals

1. **Serverless testing** — Test handlers without network
2. **Fast** — Milliseconds, not seconds
3. **Ergonomic** — Clean, readable test code
4. **Complete** — Test all framework features
5. **Isolated** — No global state

---

## 3. Testing Tiers

### Tier 1: Unit Tests (No Server)

Test individual handlers in isolation.

```java
@Test
void testGetUser() {
    Handler handler = c -> c.json(new User("123", "Alice"));

    MockContext ctx = MockContext.get("/users/123");
    handler.handle(ctx);

    assertThat(ctx.statusCode()).isEqualTo(200);
    assertThat(ctx.bodyAs(User.class).name()).isEqualTo("Alice");
}
```

### Tier 2: Router Tests (No Server)

Test routing logic without server.

```java
@Test
void testRouting() {
    Router router = UserRoutes.router();

    assertThat(router.hasRoute("GET", "/users")).isTrue();
    assertThat(router.hasRoute("POST", "/users")).isTrue();
    assertThat(router.hasRoute("DELETE", "/users/:id")).isTrue();
}
```

### Tier 3: Integration Tests (With Server)

Full end-to-end with real HTTP.

```java
@Test
void testFullStack() {
    TestApp app = TestApp.create();
    app.route(UserRoutes::router);

    Response response = app.get("/users/123");

    assertThat(response.status()).isEqualTo(200);
    assertThat(response.bodyAs(User.class).id()).isEqualTo("123");
}
```

---

## 4. MockContext

Core testing primitive for handler tests.

```java
package io.axiom.test;

public final class MockContext implements Context {

    // --- Factory Methods ---

    public static MockContext get(String path) {
        return new MockContext("GET", path);
    }

    public static MockContext post(String path) {
        return new MockContext("POST", path);
    }

    public static MockContext post(String path, Object body) {
        MockContext ctx = new MockContext("POST", path);
        ctx.setRequestBody(body);
        return ctx;
    }

    public static MockContext put(String path, Object body) {
        MockContext ctx = new MockContext("PUT", path);
        ctx.setRequestBody(body);
        return ctx;
    }

    public static MockContext delete(String path) {
        return new MockContext("DELETE", path);
    }

    public static MockContext of(String method, String path) {
        return new MockContext(method, path);
    }

    // --- Builder for Complex Requests ---

    public static Builder builder() {
        return new Builder();
    }

    public static final class Builder {
        private String method = "GET";
        private String path = "/";
        private Map<String, String> headers = new HashMap<>();
        private Map<String, String> queryParams = new HashMap<>();
        private Map<String, String> pathParams = new HashMap<>();
        private Object body;
        private Map<String, Object> state = new HashMap<>();

        public Builder method(String method) { this.method = method; return this; }
        public Builder path(String path) { this.path = path; return this; }
        public Builder header(String name, String value) { headers.put(name, value); return this; }
        public Builder query(String name, String value) { queryParams.put(name, value); return this; }
        public Builder param(String name, String value) { pathParams.put(name, value); return this; }
        public Builder body(Object body) { this.body = body; return this; }
        public Builder state(String key, Object value) { state.put(key, value); return this; }

        public MockContext build() {
            MockContext ctx = new MockContext(method, path);
            ctx.setHeaders(headers);
            ctx.setQueryParams(queryParams);
            ctx.setPathParams(pathParams);
            ctx.setRequestBody(body);
            state.forEach(ctx::set);
            return ctx;
        }
    }

    // --- Response Inspection ---

    public int statusCode() { return statusCode; }
    public Map<String, String> responseHeaders() { return responseHeaders; }
    public String responseHeader(String name) { return responseHeaders.get(name); }
    public byte[] responseBody() { return responseBody; }
    public String responseBodyText() { return new String(responseBody, UTF_8); }
    public <T> T bodyAs(Class<T> type) { return jsonCodec.decode(responseBody, type); }

    // --- State Inspection ---

    public boolean isCommitted() { return committed; }
    public Throwable error() { return error; }
}
```

---

## 5. MockContext Implementation

```java
public final class MockContext implements Context {

    private final String method;
    private final String path;
    private Map<String, String> headers = new HashMap<>();
    private Map<String, String> queryParams = new HashMap<>();
    private Map<String, String> pathParams = new HashMap<>();
    private Object requestBody;
    private final Map<String, Object> state = new HashMap<>();

    // Response state
    private int statusCode = 200;
    private final Map<String, String> responseHeaders = new HashMap<>();
    private byte[] responseBody;
    private boolean committed;
    private Throwable error;

    MockContext(String method, String path) {
        this.method = method;
        this.path = path;
    }

    // --- Context Interface Implementation ---

    @Override
    public String method() { return method; }

    @Override
    public String path() { return path; }

    @Override
    public String param(String name) { return pathParams.get(name); }

    @Override
    public String query(String name) { return queryParams.get(name); }

    @Override
    public <T> T body(Class<T> type) {
        if (requestBody == null) return null;
        if (type.isInstance(requestBody)) return type.cast(requestBody);
        // Assume JSON
        return jsonCodec.decode(jsonCodec.encode(requestBody), type);
    }

    @Override
    public Map<String, String> headers() {
        return Collections.unmodifiableMap(headers);
    }

    @Override
    public void status(int code) {
        if (committed) throw new ResponseCommittedException();
        this.statusCode = code;
    }

    @Override
    public void header(String name, String value) {
        if (committed) throw new ResponseCommittedException();
        responseHeaders.put(name, value);
    }

    @Override
    public void text(String value) {
        if (committed) throw new ResponseCommittedException();
        responseHeaders.put("Content-Type", "text/plain");
        responseBody = value.getBytes(UTF_8);
        committed = true;
    }

    @Override
    public void json(Object value) {
        if (committed) throw new ResponseCommittedException();
        responseHeaders.put("Content-Type", "application/json");
        responseBody = jsonCodec.encode(value);
        committed = true;
    }

    @Override
    public void send(byte[] data) {
        if (committed) throw new ResponseCommittedException();
        responseBody = data;
        committed = true;
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> Optional<T> get(String key, Class<T> type) {
        Object value = state.get(key);
        if (value == null) return Optional.empty();
        if (type.isInstance(value)) return Optional.of((T) value);
        return Optional.empty();
    }

    @Override
    public void set(String key, Object value) {
        state.put(key, value);
    }

    // --- Test Setup Methods ---

    void setHeaders(Map<String, String> headers) { this.headers = new HashMap<>(headers); }
    void setQueryParams(Map<String, String> params) { this.queryParams = new HashMap<>(params); }
    void setPathParams(Map<String, String> params) { this.pathParams = new HashMap<>(params); }
    void setRequestBody(Object body) { this.requestBody = body; }
    void setError(Throwable error) { this.error = error; }
}
```

---

## 6. TestRouter

Test routing without handlers.

```java
package io.axiom.test;

public final class TestRouter {

    private final Router router;

    public TestRouter(Router router) {
        this.router = router;
    }

    public static TestRouter wrap(Router router) {
        return new TestRouter(router);
    }

    /**
     * Check if route exists.
     */
    public boolean hasRoute(String method, String path) {
        return router.match(method, path) != null;
    }

    /**
     * Get all registered routes.
     */
    public List<RouteInfo> routes() {
        return router.routes().stream()
            .map(r -> new RouteInfo(r.method(), r.path()))
            .toList();
    }

    /**
     * Verify route matches with expected params.
     */
    public ParamAssert matchRoute(String method, String path) {
        RouteMatch match = router.match(method, path);
        if (match == null) {
            throw new AssertionError("No route matches " + method + " " + path);
        }
        return new ParamAssert(match.params());
    }

    public record RouteInfo(String method, String path) {}

    public record ParamAssert(Map<String, String> params) {
        public ParamAssert hasParam(String name, String value) {
            if (!params.containsKey(name)) {
                throw new AssertionError("Missing param: " + name);
            }
            if (!params.get(name).equals(value)) {
                throw new AssertionError("Param " + name + " expected " + value + " but was " + params.get(name));
            }
            return this;
        }
    }
}
```

---

## 7. TestApp

Full integration testing with embedded server.

```java
package io.axiom.test;

public final class TestApp implements AutoCloseable {

    private final App app;
    private final int port;
    private final HttpClient client;

    private TestApp(App app, int port) {
        this.app = app;
        this.port = port;
        this.client = HttpClient.newHttpClient();
    }

    public static TestApp create() {
        return create(ServerConfig.builder()
            .port(0)  // Random available port
            .build());
    }

    public static TestApp create(ServerConfig config) {
        App app = new TestServerApp(config);
        app.listen(config.port());
        return new TestApp(app, app.port());
    }

    // --- Route Setup ---

    public TestApp route(Router router) {
        app.route(router);
        return this;
    }

    public TestApp route(String basePath, Router router) {
        app.route(basePath, router);
        return this;
    }

    public TestApp use(MiddlewareHandler middleware) {
        app.use(middleware);
        return this;
    }

    // --- Request Methods ---

    public Response get(String path) {
        return request("GET", path, null);
    }

    public Response post(String path, Object body) {
        return request("POST", path, body);
    }

    public Response put(String path, Object body) {
        return request("PUT", path, body);
    }

    public Response delete(String path) {
        return request("DELETE", path, null);
    }

    public RequestBuilder request() {
        return new RequestBuilder(this);
    }

    private Response request(String method, String path, Object body) {
        return request()
            .method(method)
            .path(path)
            .body(body)
            .execute();
    }

    // --- Cleanup ---

    @Override
    public void close() {
        app.stop();
    }

    // --- Request Builder ---

    public static final class RequestBuilder {
        private final TestApp app;
        private String method = "GET";
        private String path = "/";
        private Map<String, String> headers = new HashMap<>();
        private Object body;

        RequestBuilder(TestApp app) { this.app = app; }

        public RequestBuilder method(String method) { this.method = method; return this; }
        public RequestBuilder path(String path) { this.path = path; return this; }
        public RequestBuilder header(String name, String value) { headers.put(name, value); return this; }
        public RequestBuilder body(Object body) { this.body = body; return this; }

        public Response execute() {
            // Build and execute HTTP request
            var builder = HttpRequest.newBuilder()
                .uri(URI.create("http://localhost:" + app.port + path))
                .method(method, body != null
                    ? HttpRequest.BodyPublishers.ofString(jsonEncode(body))
                    : HttpRequest.BodyPublishers.noBody());

            headers.forEach(builder::header);
            if (body != null) {
                builder.header("Content-Type", "application/json");
            }

            try {
                var httpResponse = app.client.send(
                    builder.build(),
                    HttpResponse.BodyHandlers.ofByteArray()
                );
                return new Response(httpResponse);
            } catch (Exception e) {
                throw new RuntimeException("Request failed", e);
            }
        }
    }
}
```

---

## 8. Response Wrapper

```java
package io.axiom.test;

public final class Response {

    private final HttpResponse<byte[]> response;

    Response(HttpResponse<byte[]> response) {
        this.response = response;
    }

    public int status() {
        return response.statusCode();
    }

    public String header(String name) {
        return response.headers().firstValue(name).orElse(null);
    }

    public Map<String, List<String>> headers() {
        return response.headers().map();
    }

    public byte[] body() {
        return response.body();
    }

    public String bodyText() {
        return new String(response.body(), UTF_8);
    }

    public <T> T bodyAs(Class<T> type) {
        return jsonCodec.decode(response.body(), type);
    }

    public boolean isOk() {
        return status() >= 200 && status() < 300;
    }

    public boolean isClientError() {
        return status() >= 400 && status() < 500;
    }

    public boolean isServerError() {
        return status() >= 500;
    }
}
```

---

## 9. Custom Assertions

```java
package io.axiom.test;

public final class AxiomAssertions {

    private AxiomAssertions() {}

    // --- Context Assertions ---

    public static ContextAssert assertThat(MockContext context) {
        return new ContextAssert(context);
    }

    public static final class ContextAssert {
        private final MockContext ctx;

        ContextAssert(MockContext ctx) { this.ctx = ctx; }

        public ContextAssert hasStatus(int expected) {
            if (ctx.statusCode() != expected) {
                throw new AssertionError(
                    "Expected status " + expected + " but was " + ctx.statusCode());
            }
            return this;
        }

        public ContextAssert hasHeader(String name, String value) {
            String actual = ctx.responseHeader(name);
            if (!value.equals(actual)) {
                throw new AssertionError(
                    "Expected header " + name + "=" + value + " but was " + actual);
            }
            return this;
        }

        public ContextAssert hasContentType(String expected) {
            return hasHeader("Content-Type", expected);
        }

        public ContextAssert hasJsonBody() {
            return hasContentType("application/json");
        }

        public ContextAssert bodyContains(String substring) {
            if (!ctx.responseBodyText().contains(substring)) {
                throw new AssertionError(
                    "Expected body to contain '" + substring + "' but was: " + ctx.responseBodyText());
            }
            return this;
        }

        public <T> ContextAssert bodyEquals(T expected) {
            T actual = ctx.bodyAs((Class<T>) expected.getClass());
            if (!expected.equals(actual)) {
                throw new AssertionError(
                    "Expected body " + expected + " but was " + actual);
            }
            return this;
        }

        public ContextAssert isCommitted() {
            if (!ctx.isCommitted()) {
                throw new AssertionError("Expected response to be committed");
            }
            return this;
        }

        public ContextAssert isNotCommitted() {
            if (ctx.isCommitted()) {
                throw new AssertionError("Expected response to not be committed");
            }
            return this;
        }
    }

    // --- Response Assertions ---

    public static ResponseAssert assertThat(Response response) {
        return new ResponseAssert(response);
    }

    public static final class ResponseAssert {
        private final Response response;

        ResponseAssert(Response response) { this.response = response; }

        public ResponseAssert isOk() {
            if (!response.isOk()) {
                throw new AssertionError(
                    "Expected 2xx but was " + response.status());
            }
            return this;
        }

        public ResponseAssert hasStatus(int expected) {
            if (response.status() != expected) {
                throw new AssertionError(
                    "Expected status " + expected + " but was " + response.status());
            }
            return this;
        }

        // Similar methods...
    }
}
```

---

## 10. Example Test Patterns

### 10.1 Unit Test

```java
import static io.axiom.test.AxiomAssertions.*;

class UserHandlerTest {

    private UserService userService = mock(UserService.class);
    private Handler handler = new UserHandler(userService);

    @Test
    void getUser_found() throws Exception {
        when(userService.find("123")).thenReturn(new User("123", "Alice"));

        MockContext ctx = MockContext.builder()
            .method("GET")
            .path("/users/123")
            .param("id", "123")
            .build();

        handler.handle(ctx);

        assertThat(ctx)
            .hasStatus(200)
            .hasJsonBody()
            .bodyEquals(new User("123", "Alice"));
    }

    @Test
    void getUser_notFound() throws Exception {
        when(userService.find("999")).thenReturn(null);

        MockContext ctx = MockContext.builder()
            .method("GET")
            .path("/users/999")
            .param("id", "999")
            .build();

        assertThrows(UserNotFoundException.class, () -> handler.handle(ctx));
    }
}
```

### 10.2 Router Test

```java
class UserRoutesTest {

    @Test
    void hasExpectedRoutes() {
        TestRouter router = TestRouter.wrap(UserRoutes.router());

        assertThat(router.hasRoute("GET", "/users")).isTrue();
        assertThat(router.hasRoute("GET", "/users/123")).isTrue();
        assertThat(router.hasRoute("POST", "/users")).isTrue();
        assertThat(router.hasRoute("DELETE", "/users/123")).isTrue();
    }

    @Test
    void extractsParams() {
        TestRouter router = TestRouter.wrap(UserRoutes.router());

        router.matchRoute("GET", "/users/123")
            .hasParam("id", "123");
    }
}
```

### 10.3 Integration Test

```java
class UserApiIntegrationTest {

    private TestApp app;

    @BeforeEach
    void setup() {
        app = TestApp.create();
        app.route(UserRoutes::router);
    }

    @AfterEach
    void teardown() {
        app.close();
    }

    @Test
    void createAndGetUser() {
        // Create
        Response createResponse = app.post("/users", new UserCreate("Alice"));
        assertThat(createResponse).hasStatus(201);
        User created = createResponse.bodyAs(User.class);

        // Get
        Response getResponse = app.get("/users/" + created.id());
        assertThat(getResponse)
            .isOk()
            .bodyEquals(created);
    }
}
```

---

## 11. JUnit 5 Extension (Optional)

```java
@ExtendWith(AxiomExtension.class)
class UserApiTest {

    @InjectTestApp
    TestApp app;

    @BeforeEach
    void setup() {
        app.route(UserRoutes::router);
    }

    @Test
    void test() {
        // app is automatically created and closed
    }
}
```

---

## 12. Non-Goals

- Performance testing utilities (use JMH)
- Load testing (use external tools)
- Mock HTTP server (use MockContext)
- Browser testing (out of scope)

---

## 13. Final Decision

- MockContext for handler unit tests
- TestRouter for routing tests
- TestApp for integration tests
- AxiomAssertions for ergonomic assertions
- Optional JUnit extension

**Approved for implementation.**

---
