## A DX-First, Functional Java Web Framework (Java 21+)

**Status:** Draft

**Target Java Version:** 21+ (Required)

**Audience:** Backend engineers, framework authors

**Inspired by:** NextRush, Hono, Express (DX), modern JVM (Loom)
---

## A DX-First, Functional Java Web Framework (Java 21+)

**Status:** Draft

**Target Java Version:** 21+ (Required)

**Audience:** Backend engineers, framework authors

**Inspired by:** NextRush, Hono, Express (DX), modern JVM (Loom)

---

## 1. Motivation

The Java ecosystem lacks a **modern, low-noise, DX-first web framework** comparable to Hono or NextRush.

Existing frameworks suffer from:

- Annotation overload
- Reflection-heavy request paths
- Hidden execution flow
- Boilerplate controllers and DTO glue
- Reactive APIs leaking complexity into user code

With **Java 21**, these constraints no longer exist.

This RFC proposes a framework that:

- Feels imperative and simple
- Is functional internally
- Scales via virtual threads
- Avoids annotations and magic
- Prioritizes **developer experience above all**

---

## 2. Core Design Principles

1. **DX first, purity second**
2. **Imperative to read, functional underneath**
3. **Explicit execution flow**
4. **Zero reflection in hot paths**
5. **Blocking syntax, async execution**
6. **Minimal surface area**
7. **Composition over inheritance**

---

## 3. Non-Goals

- Not a Spring replacement
- Not reactive-streams based
- Not annotation-driven
- Not a full DI container
- Not ORM-coupled

---

## 4. Target Developer Experience (DX)

This is the **north star**.

All design decisions must preserve this.

```java
Router router = new Router();

router.get("/health", c -> c.text("OK"));

router.get("/users/:id", c ->
    c.json(userService.find(c.param("id")))
);

router.post("/users", c -> {
    var req = c.body(UserCreate.class);
    c.status(201);
    c.json(userService.create(req));
});

App app = new App();
app.use(auth());
app.route(router);
app.listen(8080);

```

**No:**

- Wrappers (`ok()`, `Response<T>`)
- Nested DSLs
- Annotations
- Reactive types

---

## 5. Execution Model (Critical)

### 5.1 Async Execution Without Async Syntax

- Each request runs on a **virtual thread**
- User code is written **synchronously**
- Runtime scales concurrently

```java
User user = service.find(id); // blocking syntax

```

Under the hood:

- Virtual threads
- Non-blocking scalability
- No callback hell

**This is intentional.**

---

## 6. Core Abstractions

### 6.1 Handler

```java
@FunctionalInterface
public interface Handler {
    void handle(Context c) throws Exception;
}

```

Rationale:

- Clean lambdas
- No generics noise
- No response wrapping
- Familiar to JS developers

---

### 6.2 Context (Primary DX Surface)

```java
public interface Context {

    // Request
    String method();
    String path();

    String param(String name);        // /users/:id
    String query(String name);        // ?page=1
    <T> T body(Class<T> type);        // JSON → Object
    Map<String, String> headers();

    // Response
    void status(int code);
    void header(String name, String value);
    void text(String value);
    void json(Object value);
    void send(byte[] data);

    // Metadata
    Optional<Object> state(String key);
}

```

Design notes:

- Request data is immutable
- Body parsed once and cached
- JSON is default
- No annotations

---

## 7. Routing API

### 7.1 Router

```java
public final class Router {

    public void get(String path, Handler handler);
    public void post(String path, Handler handler);
    public void put(String path, Handler handler);
    public void delete(String path, Handler handler);

}

```

Usage is **imperative and linear**, not declarative data DSLs.

---

### 7.2 Path Parameters

```java
/users/:id

```

Usage:

```java
c.param("id");

```

Internals:

- Precompiled matcher
- Extracted once per request

---

## 8. Application Composition

### 8.1 App

```java
public final class App {

    public void use(Middleware middleware);
    public void route(Router router);
    public void listen(int port);

}

```

Execution order:

1. Middleware (registration order)
2. Router match
3. Handler
4. Response write

---

## 9. Middleware Design

### 9.1 Public DX (Express / Hono style)

```java
app.use((c, next) -> {
    if (!c.state("user").isPresent()) {
        c.status(401);
        c.text("Unauthorized");
        return;
    }
    next.run();
});

```

This is the **only DX users see**.

---

### 9.2 Middleware Interfaces

### Public

```java
@FunctionalInterface
public interface MiddlewareHandler {
    void handle(Context c, Next next) throws Exception;
}

public interface Next {
    void run() throws Exception;
}

```

### Internal (Functional Core)

```java
@FunctionalInterface
interface Middleware {
    Handler apply(Handler next);
}

```

The framework **adapts public DX → functional core**.

---

### 9.3 Why This Design

- Clean user code
- Functional composition internally
- Explicit control flow
- No inheritance
- No annotations

---

## 10. Error Handling

### 10.1 Global Error Handler

```java
app.onError((c, e) -> {
    c.status(500);
    c.json(Map.of("error", e.getMessage()));
});

```

Rules:

- No try/catch in handlers
- All uncaught exceptions flow here
- Predictable behavior

---

## 11. Concurrency & Safety

- Virtual threads per request
- No shared mutable state
- Optional use of `ScopedValue` internally
- No `ThreadLocal` leakage

User DX remains simple.

---

## 12. Runtime Architecture

### 12.1 Adapter-Based

```
runtime/
 ├─ jdk-http/
 ├─ netty/
 └─ undertow/

```

Adapters:

- Translate native request → Context
- Execute middleware chain
- Invoke handler
- Write response

---

## 13. Internal Module Layout

```
core/
 ├─ app/
 │   └─ App
 ├─ routing/
 │   ├─ Router
 │   ├─ Route
 │   └─ Matcher
 ├─ context/
 │   └─ Context
 ├─ middleware/
 │   ├─ Middleware
 │   └─ Next
 ├─ runtime/
 │   └─ Server

```

---

## 14. Testing Strategy

Handlers are **serverless by default**.

```java
Context c = TestContext.json("{\"name\":\"A\"}");
handler.handle(c);

assertEquals(201, c.status());

```

No mocks.

No containers.

No server boot.

---

## 15. DX Comparison (High Level)

| Feature | This Framework | Spring |
| --- | --- | --- |
| Routing | `router.get()` | Annotations |
| Middleware | Function | Filters / AOP |
| Async | Virtual threads | Thread pools |
| Reflection | None | Heavy |
| Learning curve | Low | High |
| Execution flow | Explicit | Hidden |

---

## 16. Future (Out of Scope)

- OpenAPI generator
- Validation module
- Plugin system
- DI bridge
- HTTP/3

---

## 17. Final Decision

This RFC defines a **modern Java web framework** that:

- Matches Hono / NextRush DX
- Uses Java 21 correctly
- Avoids legacy Java patterns
- Prioritizes readability and control
- Scales without async syntax
