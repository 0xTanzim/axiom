# RFC-0014: Validation System (Jakarta Validation Integration)

**Status:** Draft
**Priority:** P1 (DX-Critical)
**Target Java:** 25 LTS
**Module:** `axiom-validation`
**Audience:** Framework users & contributors

---

## 1. Purpose

This RFC defines a **validation system** for Axiom that:

- Validates request bodies and DTOs
- Uses industry-standard Jakarta Validation (JSR-380)
- Provides clear, structured error messages
- Is optional (users opt-in by adding the dependency)
- Requires zero framework boilerplate

---

## 2. Design Goal (North Star)

> **Validate objects with one method call. Get clear errors.**

Validation must:
- Work with standard annotations (@NotNull, @Size, @Email, etc.)
- Support custom validators
- Return structured error information
- Integrate cleanly with HTTP error responses

---

## 3. Core Principles (LOCKED)

1. **Standard over custom** — Use Jakarta Validation, not custom system
2. **Optional dependency** — Zero cost if not used
3. **Fail fast with context** — Clear error messages with field paths
4. **Type-safe results** — No string parsing for error handling
5. **No magic** — Explicit validation calls, no auto-validation

---

## 4. Technology Choice

### Implementation: Hibernate Validator

**Why Hibernate Validator:**
- Reference implementation of Jakarta Validation 3.0
- Battle-tested (Spring, Quarkus, Micronaut all use it)
- Works standalone (no container required)
- Excellent documentation
- Active maintenance

**Dependencies:**
```xml
<dependency>
    <groupId>jakarta.validation</groupId>
    <artifactId>jakarta.validation-api</artifactId>
    <version>3.0.2</version>
</dependency>
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>8.0.1.Final</version>
</dependency>
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>jakarta.el</artifactId>
    <version>4.0.2</version>
</dependency>
```

---

## 5. Public API

### 5.1 Main Entry Point: `AxiomValidator`

```java
public final class AxiomValidator {

    // Validate an object, return result
    public static <T> ValidationResult<T> validate(T object);

    // Validate specific property
    public static <T> ValidationResult<T> validateProperty(T object, String property);

    // Validate and throw if invalid
    public static <T> T validateOrThrow(T object);
}
```

### 5.2 Validation Result

```java
public sealed interface ValidationResult<T> {

    boolean isValid();

    T value();

    List<ValidationError> errors();

    T getOrThrow() throws ValidationException;

    record Valid<T>(T value) implements ValidationResult<T> {}

    record Invalid<T>(T value, List<ValidationError> errors) implements ValidationResult<T> {}
}
```

### 5.3 Validation Error

```java
public record ValidationError(
    String path,        // e.g., "user.email", "items[0].name"
    String message,     // Human-readable: "must not be blank"
    Object invalidValue // The actual invalid value
) {}
```

### 5.4 Validation Exception

```java
public class ValidationException extends RuntimeException {

    public List<ValidationError> errors();

    public Map<String, List<String>> toErrorMap();
}
```

---

## 6. Usage Examples

### 6.1 Define Validated DTO

```java
public record CreateUserRequest(
    @NotBlank(message = "Name is required")
    String name,

    @Email(message = "Invalid email format")
    @NotBlank(message = "Email is required")
    String email,

    @Min(value = 18, message = "Must be at least 18")
    int age
) {}
```

### 6.2 Validate in Handler

```java
app.post("/users", ctx -> {
    CreateUserRequest request = ctx.body(CreateUserRequest.class);

    ValidationResult<CreateUserRequest> result = AxiomValidator.validate(request);

    if (!result.isValid()) {
        ctx.status(400);
        ctx.json(result.errors());
        return;
    }

    // Process valid request
    userService.create(result.value());
    ctx.status(201);
});
```

### 6.3 Validate and Throw (Concise Style)

```java
app.post("/users", ctx -> {
    CreateUserRequest request = AxiomValidator.validateOrThrow(
        ctx.body(CreateUserRequest.class)
    );

    // Process valid request (ValidationException thrown if invalid)
    userService.create(request);
    ctx.status(201);
});
```

---

## 7. Error Response Format

When validation fails, errors are structured:

```json
{
  "errors": [
    {
      "path": "email",
      "message": "must not be blank",
      "invalidValue": ""
    },
    {
      "path": "age",
      "message": "must be at least 18",
      "invalidValue": 16
    }
  ]
}
```

---

## 8. Standard Validation Annotations

### Built-in (from Jakarta Validation)

| Annotation | Purpose |
|------------|---------|
| `@NotNull` | Not null |
| `@NotBlank` | Not null, not empty, not whitespace |
| `@NotEmpty` | Not null, not empty |
| `@Size(min, max)` | Collection/String size |
| `@Min`, `@Max` | Numeric bounds |
| `@Email` | Email format |
| `@Pattern(regexp)` | Regex match |
| `@Past`, `@Future` | Date constraints |
| `@Positive`, `@Negative` | Number sign |
| `@Valid` | Cascade validation |

### Custom Validators

Users can define custom validators following standard Jakarta Validation patterns.

---

## 9. Module Placement

### New Module: `axiom-validation`

```
axiom-validation/
├── pom.xml
└── src/main/java/com/axiom/validation/
    ├── AxiomValidator.java
    ├── ValidationResult.java
    ├── ValidationError.java
    └── ValidationException.java
```

---

## 10. Integration with axiom-core (Future)

### Optional: `ctx.validBody()`

```java
// In Context interface (when axiom-validation is on classpath)
<T> T validBody(Class<T> type) throws ValidationException;
```

Implementation uses ServiceLoader to detect axiom-validation.
If not present, throws UnsupportedOperationException.

**Note:** This integration is OPTIONAL and may be added in a future RFC.

---

## 11. Non-Goals (Intentional)

- Automatic validation (explicit calls only)
- Method parameter validation (not needed for framework)
- Cross-field validation (use custom validators)
- i18n message bundles (use default messages)

---

## 12. Thread Safety

- `AxiomValidator` is thread-safe
- `ValidatorFactory` is created once and reused
- `Validator` instances are created per-call (cheap)

---

## 13. Error Handling

ValidationException is a RuntimeException because:
- Validation errors are user input errors
- Should propagate to error handler
- No forced try-catch clutter

---

## 14. Final Guarantee (LOCKED)

> **Axiom validation uses standard Jakarta annotations,
> returns structured errors, and requires zero boilerplate.**

---

## 15. TL;DR

- Jakarta Validation 3.0 ✅
- Hibernate Validator ✅
- `AxiomValidator.validate(object)` ✅
- `ValidationResult` with errors ✅
- Standard annotations ✅
- Optional module ✅
- Zero magic ✅
