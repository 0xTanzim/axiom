## Build Tool & Kotlin Compatibility Strategy

**Status:** Draft

**Type:** Platform / Ecosystem Design

**Applies to:** Entire Framework

**Audience:** Framework authors, contributors, users

**Motivation:** Prevent future growth pain (learned from NextRush)

---

## 1. Problem Statement

The JVM ecosystem is diverse:

- Maven
- Gradle
- Ant
- Bazel
- Custom/internal build systems
- Java
- Kotlin (first-class JVM citizen)

Many frameworks fail by:

- Binding themselves to one build tool
- Introducing plugins too early
- Treating Kotlin as an afterthought or separate system
- Coupling runtime behavior with build-time logic

This RFC defines a **strict, minimal, future-proof strategy** to avoid those mistakes.

---

## 2. Core Principle (Non-Negotiable)

> The framework is build-tool agnostic and language-friendly by design.
>
- No build tool assumptions
- No required plugins
- No code generation
- No annotation processing
- No Kotlin-first bias
- No Java-second-class treatment

---

## 3. Build Tool Strategy

### 3.1 Framework Output Contract

The framework ships as **plain JVM artifacts**:

```
framework-core.jar
framework-runtime.jar
(optional adapters)

```

That is the **only contract**.

If a build tool can consume a JAR, it works.

---

### 3.2 Maven Support (Default, Passive)

Maven users add a dependency:

```xml
<dependency>
  <groupId>io.framework</groupId>
  <artifactId>framework-core</artifactId>
  <version>0.x.y</version>
</dependency>

```

No:

- Parent POM
- Maven plugin
- BOM (optional later)

---

### 3.3 Gradle Support (Default, Passive)

Gradle users add:

```
dependencies {
    implementation("io.framework:framework-core:0.x.y")
}

```

No:

- Gradle plugin
- Task injection
- DSL coupling

---

### 3.4 Ant, Bazel, Others

Because the framework:

- Is pure Java
- Ships plain JARs
- Requires no build-time hooks

It works automatically with:

- Ant
- Bazel
- Buck
- Internal build systems

**No special handling required.**

---

### 3.5 Explicit Non-Goals (Important)

The framework will **NOT** provide (v1):

- Maven plugins
- Gradle plugins
- Code generators
- Annotation processors
- Build-time enhancement
- “framework run” commands

Reason:

> Build tools change faster than frameworks.
>

---

## 4. Runtime Execution Model (Build-Tool Independent)

Users start the app using a normal `main()` method:

```java
public final class Main {
    public static void main(String[] args) {
        App app = new App();
        app.route(router);
        app.listen(8080);
    }
}

```

Packaging style is **user choice**:

- Fat JAR
- Thin JAR
- Container
- Native image (future)

The framework does not interfere.

---

## 5. Kotlin Compatibility Strategy

### 5.1 Kotlin Support Position

> Kotlin is supported automatically, without special treatment.
>

The framework is:

- Java-first
- JVM-native
- Lambda-friendly
- Null-safe by design

This ensures Kotlin works **out of the box**.

---

### 5.2 Kotlin Usage (No Extra Modules)

Java API:

```java
router.get("/health", c -> c.text("OK"));

```

Kotlin usage:

```kotlin
router.get("/health") { c ->
    c.text("OK")
}

```

Or (idiomatic Kotlin):

```kotlin
router.get("/health") {
    text("OK")
}

```

No framework changes required.

---

### 5.3 Kotlin Is NOT a Fork

Strong rule:

❌ No separate Kotlin framework

❌ No duplicated logic

❌ No Kotlin-only features

There is **one core**, shared by:

- Java
- Kotlin

---

### 5.4 Optional Kotlin Extensions (Future, Non-Core)

In a later phase, an **optional** module may be introduced:

```
framework-kotlin

```

Purpose:

- Extension functions
- Syntax sugar only
- Zero runtime logic

Example:

```kotlin
fun Router.get(path: String, block: Context.() -> Unit) {
    this.get(path) { c -> c.block() }
}

```

Rules:

- No new behavior
- No API divergence
- No dependency from core → kotlin

---

## 6. API Design Rules for Kotlin Safety

To ensure Kotlin friendliness, the framework enforces:

- No raw null returns (use Optional where needed)
- No overloaded methods that confuse Kotlin
- No checked exceptions in public APIs
- Clear functional interfaces

These rules benefit **both** Java and Kotlin.

---

## 7. Documentation Policy

Docs must state clearly:

### Build Tools

> This framework works with Maven, Gradle, Ant, and any JVM build system.
>
>
> No plugins required.
>

### Kotlin

> Kotlin is fully supported.
>
>
> Use the Java API directly. Optional Kotlin extensions may exist.
>

No marketing exaggeration.

No hidden caveats.

---

## 8. Why This Design Prevents Future Hassle

Because it:

- Avoids build-tool lock-in
- Avoids plugin maintenance
- Avoids version coupling
- Avoids ecosystem fragmentation
- Keeps core small and stable

This is **exactly where NextRush pain came from** — and now it’s avoided.

---

## 9. Final Decisions (Frozen)

| Area | Decision |
| --- | --- |
| Build tool dependency | ❌ None |
| Maven support | ✅ Dependency only |
| Gradle support | ✅ Dependency only |
| Plugins | ❌ No |
| Kotlin support | ✅ Automatic |
| Kotlin DSL | ⚠️ Optional, later |
| Core language | Java 21+ |
| Build-time logic | ❌ None |

**These decisions are frozen.**

---

## 10. Closing Note

This RFC is not about tools.

It’s about **long-term sustainability**.

You are choosing:

- Stability over hype
- Simplicity over magic
- Growth over shortcuts

That’s how frameworks survive.
