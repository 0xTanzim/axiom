# RFC-0007: Lifecycle Management

**Status:** Draft
**Type:** Core
**Priority:** Critical
**Depends on:** RFC-0001

---

## 1. Problem Statement

Web frameworks require predictable lifecycle management for:

- Startup initialization
- Graceful shutdown
- Resource cleanup
- Error recovery

Without explicit lifecycle contracts:
- Resources leak
- Shutdown hangs
- Startup failures are unclear
- Recovery is undefined

---

## 2. Design Goals

1. **Explicit phases** — Clear state machine
2. **Hook points** — User code at each phase
3. **Ordered execution** — Predictable hook order
4. **Error handling** — Clear failure modes
5. **Graceful shutdown** — In-flight request handling
6. **Testable** — Lifecycle without server

---

## 3. Lifecycle Phases

```
         ┌─────────┐
         │  INIT   │ ← Initial state
         └────┬────┘
              │ listen() called
              ▼
         ┌─────────┐
         │STARTING │ ← Hooks running
         └────┬────┘
              │ All hooks complete
              ▼
         ┌─────────┐
         │ STARTED │ ← Accepting requests
         └────┬────┘
              │ stop() called or signal
              ▼
         ┌─────────┐
         │STOPPING │ ← Draining requests
         └────┬────┘
              │ All drained + hooks complete
              ▼
         ┌─────────┐
         │ STOPPED │ ← Terminal state
         └─────────┘

    Any phase can transition to:
         ┌─────────┐
         │  ERROR  │ ← Unrecoverable failure
         └─────────┘
```

---

## 4. Phase Definitions

### 4.1 INIT

- Default state after construction
- No resources allocated
- Configuration can be changed
- Not accepting requests

### 4.2 STARTING

- Entered when `listen()` called
- OnStart hooks execute in registration order
- Server binding occurs
- Failure → ERROR state

### 4.3 STARTED

- Server accepting requests
- OnReady hooks execute (for notification)
- Normal operation
- stop() transitions to STOPPING

### 4.4 STOPPING

- Stop accepting new connections
- Wait for in-flight requests (with timeout)
- OnShutdown hooks execute in reverse order
- Failure → ERROR + force close

### 4.5 STOPPED

- All resources released
- Terminal state
- Can restart (returns to INIT)

### 4.6 ERROR

- Unrecoverable failure occurred
- OnError hooks execute
- Resources may be partially released
- Requires restart for recovery

---

## 5. Hook Types

```java
public sealed interface LifecycleHook
    permits OnStart, OnReady, OnShutdown, OnError {

    /**
     * Runs during STARTING phase, before server accepts requests.
     * Use for: database connections, cache warming, validation.
     */
    record OnStart(ThrowingRunnable action) implements LifecycleHook {}

    /**
     * Runs after STARTED, server is accepting requests.
     * Use for: logging, health check registration, metrics.
     */
    record OnReady(Runnable action) implements LifecycleHook {}

    /**
     * Runs during STOPPING phase, in reverse registration order.
     * Use for: cleanup, connection closing, flush buffers.
     */
    record OnShutdown(ThrowingRunnable action) implements LifecycleHook {}

    /**
     * Runs when ERROR state is entered.
     * Use for: alerting, cleanup attempts, logging.
     */
    record OnError(Consumer<Throwable> action) implements LifecycleHook {}
}

@FunctionalInterface
interface ThrowingRunnable {
    void run() throws Exception;
}
```

---

## 6. Hook Registration API

```java
public interface App {

    /**
     * Register startup hook. Runs before accepting requests.
     */
    void onStart(ThrowingRunnable action);

    /**
     * Register ready hook. Runs after server starts.
     */
    void onReady(Runnable action);

    /**
     * Register shutdown hook. Runs during graceful shutdown.
     */
    void onShutdown(ThrowingRunnable action);

    /**
     * Register error hook. Runs on lifecycle failure.
     */
    void onError(Consumer<Throwable> action);
}
```

---

## 7. Hook Execution Rules

### 7.1 OnStart Hooks

1. Execute in registration order
2. All must complete before STARTED
3. If any throws → ERROR state
4. Previous successful hooks are NOT rolled back (too complex)
5. Timeout: configurable (default 30s total)

### 7.2 OnReady Hooks

1. Execute after STARTED
2. Non-blocking (should be fast)
3. Exceptions logged but don't affect state
4. For notification only

### 7.3 OnShutdown Hooks

1. Execute in **reverse** registration order (LIFO)
2. All executed even if some fail
3. Individual exceptions logged, continue to next
4. Timeout: configurable (default 30s total)

### 7.4 OnError Hooks

1. Execute when ERROR state entered
2. All executed even if some fail
3. Exceptions logged only
4. For alerting/cleanup

---

## 8. Graceful Shutdown

### 8.1 Shutdown Trigger

```java
// Programmatic
app.stop();

// Signal handling (optional, runtime provides)
Runtime.getRuntime().addShutdownHook(...);
```

### 8.2 Shutdown Sequence

1. **Stop accepting** — No new connections
2. **Drain requests** — Wait for in-flight to complete
3. **Timeout** — Force close after configured time
4. **Run hooks** — OnShutdown in reverse order
5. **Release resources** — Close server, threads
6. **Complete** — Transition to STOPPED

### 8.3 Configuration

```java
ServerConfig config = ServerConfig.builder()
    .shutdownTimeout(Duration.ofSeconds(30))
    .drainTimeout(Duration.ofSeconds(10))
    .build();
```

---

## 9. Startup Failure Handling

### 9.1 Hook Failure

```java
app.onStart(() -> {
    throw new RuntimeException("DB connection failed");
});

app.listen(8080);  // Throws StartupException
```

**Behavior:**

1. Exception caught
2. Transition to ERROR state
3. OnError hooks run
4. StartupException thrown from listen()
5. Application does not start

### 9.2 Port Binding Failure

```java
app.listen(8080);  // Port in use
```

**Behavior:**

1. BindException caught
2. Wrapped in StartupException
3. Transition to ERROR state
4. Application does not start

---

## 10. State Query API

```java
public interface App {

    /**
     * Current lifecycle phase.
     */
    LifecyclePhase phase();

    /**
     * Whether server is accepting requests.
     */
    boolean isRunning();

    /**
     * Whether server has been started at least once.
     */
    boolean wasStarted();
}

public enum LifecyclePhase {
    INIT,
    STARTING,
    STARTED,
    STOPPING,
    STOPPED,
    ERROR
}
```

---

## 11. Error Types

```java
public class LifecycleException extends AxiomException {
    public LifecycleException(String message) { ... }
    public LifecycleException(String message, Throwable cause) { ... }
}

public final class StartupException extends LifecycleException {
    public LifecyclePhase failedPhase() { ... }
}

public final class ShutdownException extends LifecycleException {
    public List<Throwable> hookFailures() { ... }
}
```

---

## 12. Example Usage

```java
App app = new JdkApp();

// Startup hooks
app.onStart(() -> {
    System.out.println("Connecting to database...");
    database.connect();
});

app.onStart(() -> {
    System.out.println("Warming cache...");
    cache.warm();
});

// Ready notification
app.onReady(() -> {
    System.out.println("Server ready at http://localhost:8080");
});

// Shutdown hooks (reverse order)
app.onShutdown(() -> {
    System.out.println("Flushing buffers...");
    buffer.flush();
});

app.onShutdown(() -> {
    System.out.println("Closing database...");
    database.close();
});

// Error handling
app.onError(e -> {
    System.err.println("Lifecycle error: " + e.getMessage());
    alerting.send("Server failed: " + e.getMessage());
});

// Start
app.route(router);
app.listen(8080);
```

---

## 13. Thread Safety

- Lifecycle state transitions are atomic
- Hook lists are immutable after listen()
- Phase queries are thread-safe
- Concurrent stop() calls are idempotent

---

## 14. Testing Support

```java
// Test lifecycle without starting server
TestApp app = new TestApp();
app.onStart(() -> initService());
app.triggerLifecycle();  // Runs hooks without server

assertEquals(LifecyclePhase.STARTED, app.phase());
```

---

## 15. Non-Goals

- Hot reload (v1)
- Configuration reload (v1)
- Health check integration (separate concern)
- Distributed lifecycle (single process only)

---

## 16. Final Decision

- Explicit 6-phase lifecycle
- Four hook types: start, ready, shutdown, error
- Graceful shutdown with configurable timeouts
- Clear error propagation
- Testable without server

**Approved for implementation.**

---
