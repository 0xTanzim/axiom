# RFC-0008: Error Handling Architecture

**Status:** Draft
**Type:** Core
**Priority:** High
**Depends on:** RFC-0001, RFC-0004

---

## 1. Problem Statement

Error handling in frameworks is often:

- Inconsistent (different errors handled differently)
- Opaque (errors swallowed or hidden)
- Insecure (stack traces exposed in production)
- Inflexible (one-size-fits-all responses)

Axiom needs explicit, predictable error handling.

---

## 2. Design Goals

1. **Predictable** — Clear error flow
2. **Explicit** — No hidden error handling
3. **Secure** — No information leakage
4. **Flexible** — User-customizable
5. **Debug-friendly** — Useful in development
6. **Production-safe** — Secure by default

---

## 3. Error Categories

### 3.1 Framework Errors

Errors from Axiom internals:

| Error | HTTP Status | Description |
|-------|-------------|-------------|
| `RouteNotFoundException` | 404 | No matching route |
| `MethodNotAllowedException` | 405 | Route exists, wrong method |
| `BodyParseException` | 400 | Body parsing failed |
| `ResponseCommittedException` | - | Response already sent |

### 3.2 User Errors

Errors from user handler/middleware:

- `RuntimeException` subclasses
- Business exceptions
- Unchecked exceptions

### 3.3 System Errors

JVM/system level:

- `OutOfMemoryError` — Not caught
- `StackOverflowError` — Not caught
- `Error` subclasses — Let propagate

---

## 4. Exception Hierarchy

```java
public class AxiomException extends RuntimeException {

    public AxiomException(String message) {
        super(message);
    }

    public AxiomException(String message, Throwable cause) {
        super(message, cause);
    }
}

// Routing errors
public final class RouteNotFoundException extends AxiomException {
    private final String method;
    private final String path;

    public RouteNotFoundException(String method, String path) {
        super("No route found for " + method + " " + path);
        this.method = method;
        this.path = path;
    }

    public String method() { return method; }
    public String path() { return path; }
}

public final class MethodNotAllowedException extends AxiomException {
    private final String path;
    private final Set<String> allowedMethods;

    // Similar constructor...
}

// Body errors
public final class BodyParseException extends AxiomException {
    private final Class<?> targetType;
    private final String contentType;

    // Similar constructor...
}

// Response errors
public final class ResponseCommittedException extends AxiomException {
    public ResponseCommittedException() {
        super("Response already committed, cannot modify");
    }
}

// Lifecycle errors
public final class StartupException extends AxiomException { }
public final class ShutdownException extends AxiomException { }
```

---

## 5. Error Handler Contract

```java
@FunctionalInterface
public interface ErrorHandler {
    /**
     * Handle an error that occurred during request processing.
     *
     * @param c The context (may be partially written)
     * @param error The error that occurred
     */
    void handle(Context c, Throwable error);
}
```

---

## 6. Error Handler Registration

```java
public interface App {

    /**
     * Register global error handler.
     * Replaces default handler.
     */
    void onError(ErrorHandler handler);
}
```

Single handler for simplicity. User composes internally if needed.

---

## 7. Default Error Handler

```java
final class DefaultErrorHandler implements ErrorHandler {

    @Override
    public void handle(Context c, Throwable error) {
        if (error instanceof RouteNotFoundException e) {
            c.status(404);
            c.json(Map.of(
                "error", "Not Found",
                "path", e.path()
            ));
        } else if (error instanceof MethodNotAllowedException e) {
            c.status(405);
            c.header("Allow", String.join(", ", e.allowedMethods()));
            c.json(Map.of(
                "error", "Method Not Allowed",
                "allowed", e.allowedMethods()
            ));
        } else if (error instanceof BodyParseException e) {
            c.status(400);
            c.json(Map.of(
                "error", "Bad Request",
                "message", "Invalid request body"
            ));
        } else {
            // Generic 500 for unknown errors
            c.status(500);
            c.json(Map.of(
                "error", "Internal Server Error"
            ));
            // Log the actual error
            logger.error("Unhandled exception", error);
        }
    }
}
```

---

## 8. Error Flow

```
Handler/Middleware throws
         │
         ▼
┌─────────────────────────┐
│ Response committed?      │
└────────────┬────────────┘
             │
     ┌───────┴───────┐
     │ Yes           │ No
     ▼               ▼
┌─────────┐   ┌─────────────────┐
│ Log     │   │ Error Handler   │
│ error   │   │ (user or default)│
│ only    │   └────────┬────────┘
└─────────┘            │
                       ▼
              ┌─────────────────┐
              │ Write error     │
              │ response        │
              └─────────────────┘
```

---

## 9. Error Handler Failures

What if error handler throws?

```java
app.onError((c, e) -> {
    throw new RuntimeException("Error handler failed!");
});
```

**Behavior:**

1. Log both original error and handler error
2. Attempt minimal 500 response (if not committed)
3. Do NOT recursively call error handler
4. Close connection if needed

```java
// Internal handling
try {
    errorHandler.handle(c, originalError);
} catch (Throwable handlerError) {
    logger.error("Error handler failed", handlerError);
    logger.error("Original error was", originalError);

    if (!c.isCommitted()) {
        try {
            c.status(500);
            c.text("Internal Server Error");
        } catch (Throwable ignored) {
            // Connection may be broken
        }
    }
}
```

---

## 10. Committed Response Handling

Once response is committed (headers/body sent), we cannot change it.

```java
c.text("Starting...");  // Committed!
throw new RuntimeException("Oops");  // Too late
```

**Behavior:**

1. Detect `isCommitted()` state
2. Log error (don't suppress)
3. Optionally close connection (HTTP/1.1)
4. Cannot send error response

---

## 11. Development vs Production Mode

### 11.1 Development Mode

```java
// Stack traces in response (opt-in)
app.developmentMode(true);

// Error response includes:
{
    "error": "NullPointerException",
    "message": "Cannot invoke method on null",
    "stack": [
        "com.example.UserService.find(UserService.java:42)",
        "com.example.UserHandler.handle(UserHandler.java:18)",
        ...
    ]
}
```

### 11.2 Production Mode (default)

```java
// Safe error responses
{
    "error": "Internal Server Error"
}
// Stack trace logged server-side only
```

---

## 12. Error Response Format

Standard JSON error format:

```java
public record ErrorResponse(
    String error,           // Short error name
    String message,         // Human-readable (optional)
    String code,            // Machine-readable code (optional)
    Map<String, Object> details  // Additional info (optional)
) {
    public static ErrorResponse of(String error) {
        return new ErrorResponse(error, null, null, null);
    }

    public static ErrorResponse of(String error, String message) {
        return new ErrorResponse(error, message, null, null);
    }
}
```

---

## 13. Custom Error Types

Users can define domain errors:

```java
public class UserNotFoundException extends RuntimeException {
    private final String userId;

    public UserNotFoundException(String userId) {
        super("User not found: " + userId);
        this.userId = userId;
    }

    public String userId() { return userId; }
}

// Custom handler
app.onError((c, e) -> {
    if (e instanceof UserNotFoundException unf) {
        c.status(404);
        c.json(Map.of(
            "error", "User Not Found",
            "userId", unf.userId()
        ));
    } else if (e instanceof AxiomException) {
        // Delegate to default for framework errors
        DefaultErrorHandler.INSTANCE.handle(c, e);
    } else {
        c.status(500);
        c.json(Map.of("error", "Internal Server Error"));
    }
});
```

---

## 14. Async Error Handling

With virtual threads, async is rare. But if user spawns threads:

```java
handler = c -> {
    Thread.startVirtualThread(() -> {
        // Error here won't be caught by framework!
        throw new RuntimeException("Async error");
    });
};
```

**Behavior:**

1. Framework only catches errors in request thread
2. User-spawned thread errors are user's responsibility
3. Document this clearly

---

## 15. Error Logging

Framework logs errors at appropriate levels:

| Error Type | Log Level | Logged |
|------------|-----------|--------|
| 4xx | DEBUG | Path, status |
| 5xx | ERROR | Full stack trace |
| Handler error | ERROR | Full stack trace |
| Error handler fail | ERROR | Both errors |

---

## 16. Non-Goals

- Exception mapping annotations
- Multiple error handlers (use composition)
- Async error handler
- Recovery/retry (user responsibility)

---

## 17. Example: Full Custom Handler

```java
app.onError((c, error) -> {
    // Request ID for correlation
    String requestId = UUID.randomUUID().toString();
    c.header("X-Request-Id", requestId);

    if (error instanceof RouteNotFoundException) {
        c.status(404);
        c.json(Map.of(
            "error", "NOT_FOUND",
            "message", "The requested resource was not found",
            "requestId", requestId
        ));
    } else if (error instanceof ValidationException ve) {
        c.status(400);
        c.json(Map.of(
            "error", "VALIDATION_ERROR",
            "message", "Request validation failed",
            "details", ve.violations(),
            "requestId", requestId
        ));
    } else if (error instanceof AuthenticationException) {
        c.status(401);
        c.json(Map.of(
            "error", "UNAUTHORIZED",
            "message", "Authentication required",
            "requestId", requestId
        ));
    } else {
        // Log full error server-side
        logger.error("Request {} failed: {}", requestId, error.getMessage(), error);

        c.status(500);
        c.json(Map.of(
            "error", "INTERNAL_ERROR",
            "message", "An unexpected error occurred",
            "requestId", requestId
        ));
    }
});
```

---

## 18. Final Decision

- Single global error handler
- Typed exception hierarchy
- Safe production defaults
- Development mode with stack traces
- Clear committed response handling
- No recursion on handler failure

**Approved for implementation.**

---
