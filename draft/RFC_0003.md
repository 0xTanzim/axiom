## Routing Matcher Algorithm

**Status:** Draft

**Depends on:** RFC-0001

**Target:** High-performance, predictable routing

**Priority:** Critical (hot path)

---

## 1. Problem Statement

Routing is on the **hot path** of every request.

Common mistakes in Java frameworks:

- Regex-heavy matching
- Reflection
- Re-parsing paths per request
- Unclear precedence rules

We need a matcher that is:

- Fast
- Predictable
- Easy to reason about
- Compatible with `router.get("/users/:id")` DX

---

## 2. Design Goals

1. **O(n) path matching**
2. **No regex per request**
3. **Precompiled route structure**
4. **Deterministic precedence**
5. **Low memory overhead**
6. **Simple debugging**

---

## 3. Supported Path Syntax

| Pattern | Meaning |
| --- | --- |
| `/users` | Static path |
| `/users/:id` | Named param |
| `/files/*` | Wildcard (catch-all) |

❌ No optional params

❌ No inline regex

❌ No ambiguity

This is intentional.

---

## 4. Route Normalization (Compile Time)

When a route is registered:

```java
router.get("/users/:id", handler);

```

It is **compiled once** into segments:

```
["users", ":id"]

```

Internal representation:

```java
sealed interface Segment
    permits StaticSegment, ParamSegment, WildcardSegment {}

record StaticSegment(String value) implements Segment {}
record ParamSegment(String name) implements Segment {}
record WildcardSegment() implements Segment {}

```

---

## 5. Routing Tree (Trie-Based)

Routes are stored in a **method-scoped trie**.

### Structure

```
GET
 └─ users
     ├─ :id
     │   └─ (handler)
     └─ health
         └─ (handler)

```

Each HTTP method has its own root node.

---

## 6. Trie Node Definition

```java
final class Node {
    Map<String, Node> staticChildren;
    Node paramChild;
    Node wildcardChild;
    Handler handler;
}

```

Rules:

- Static match > param match > wildcard
- Only one param child allowed per level
- Wildcard always terminates path

---

## 7. Matching Algorithm (Request Time)

Given request:

```
GET /users/42

```

### Steps

1. Split path once:

```java
["users", "42"]

```

1. Traverse trie:
    - Match static `"users"`
    - No static `"42"` → try param
    - Capture `id = "42"`
2. Handler found → execute

### Pseudocode

```java
Node node = root;
for (segment : pathSegments) {
    if (node.staticChildren.contains(segment)) {
        node = node.staticChildren.get(segment);
    } else if (node.paramChild != null) {
        params.put(node.paramChild.name(), segment);
        node = node.paramChild;
    } else if (node.wildcardChild != null) {
        node = node.wildcardChild;
        break;
    } else {
        return NOT_FOUND;
    }
}

```

---

## 8. Parameter Storage

Params are stored in a **request-local map**:

```java
Map<String, String> params;

```

Exposed via:

```java
c.param("id");

```

No parsing.

No conversion.

Framework stays neutral.

---

## 9. Route Precedence Rules (Important)

Order of matching at each segment:

1. Static
2. Param (`:id`)
3. Wildcard ()

Example:

```java
/users/me
/users/:id
/users/*

```

Request `/users/me` → **static wins**

This guarantees **predictable behavior**.

---

## 10. Performance Characteristics

- Allocation-free matching (except params)
- No regex
- No reflection
- No backtracking
- O(segments) time

This scales linearly and predictably.

---

## 11. Debuggability

Each node retains:

- Original path
- Handler reference

Optional debug mode:

```java
app.debugRoutes();

```

Outputs:

```
GET  /users/:id
POST /users
GET  /health

```

---

## 12. Final Decision

- Trie-based matcher
- Static-first precedence
- Minimal syntax
- Compiled once, matched fast

**Approved for implementation.**

---
