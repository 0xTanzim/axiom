# RFC-0011: Axiom Dependency Injection

| Field       | Value                                        |
| ----------- | -------------------------------------------- |
| **Status**  | Draft                                        |
| **Created** | 2026-01-18                                   |
| **Author**  | Axiom Team                                   |
| **Scope**   | axiom-di (new module)                        |

---

## 1. Summary

**Axiom DI** provides compile-time dependency injection by **wrapping a battle-tested DI engine** (not reinventing).

**Philosophy**: Enhance proven solutions, don't reinvent them.

---

## 2. Key Decision: Wrap, Don't Reinvent

### 2.1 Why NOT Build from Scratch?

Building a DI container from scratch means:
- ❌ Years of edge-case discovery
- ❌ Cycle detection bugs
- ❌ Scope management complexity
- ❌ No community trust
- ❌ Reinventing what Google already solved

### 2.2 Battle-Tested Options

| Library | Type | Reflection | Maturity |
|---------|------|------------|----------|
| **Dagger 2** | Compile-time | None | Google, Android (10+ years) |
| **Guice** | Runtime | Yes | Google (15+ years) |
| **Micronaut DI** | Compile-time | None | Modern (5+ years) |
| **Spring DI** | Runtime | Heavy | Industry standard |

### 2.3 Recommendation: Wrap Dagger 2

**Why Dagger 2?**
- ✅ True compile-time DI (no reflection)
- ✅ Generates readable Java code (debuggable!)
- ✅ Battle-tested by Google & Android ecosystem
- ✅ Cycle detection at compile time
- ✅ Zero runtime overhead
- ✅ Aligns with Axiom's "explicit over magic" philosophy

**Axiom adds:**
- `@Routes("/path")` auto-mounting (Dagger doesn't know about HTTP)
- `@Repository` stereotype (Dagger doesn't have layers)
- `Axiom.start()` zero-config bootstrap
- Config record injection from AxiomConfig

---

## 3. What We DROP (Rejected Ideas)

| Dropped | Reason |
|---------|--------|
| ❌ Custom annotation processor from scratch | Reinventing Dagger poorly |
| ❌ Java Records for services | Ugly with 4+ deps: `record Svc(A a, B b, C c, D d, E e)` |
| ❌ Runtime scanning | Against Axiom principles |
| ❌ Field injection | Untestable, hidden dependencies |

---

## 4. Final DX: Clean Constructor Injection

### 4.1 Standard Class Pattern (Recommended)

```java
@Service
public class AuthService {
    private final UserRepository userRepository;
    private final JwtService jwtService;
    private final PasswordEncoder passwordEncoder;

    @Inject  // Dagger annotation
    public AuthService(UserRepository userRepository, 
                       JwtService jwtService,
                       PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.jwtService = jwtService;
        this.passwordEncoder = passwordEncoder;
    }

    public AuthResponse login(LoginRequest request) {
        // Business logic
    }
}
```

**Why this is GOOD DX:**
- Clear what dependencies exist (fields visible)
- IDE auto-complete works
- Easy to read with 5+ dependencies
- Standard Java pattern everyone knows

### 4.2 Routes with Auto-Mounting

```java
@Routes("/auth")  // Axiom annotation → auto-mounts!
public class AuthRoutes {
    private final AuthService authService;

    @Inject
    public AuthRoutes(AuthService authService) {
        this.authService = authService;
    }

    public Router router() {
        Router r = new Router();
        r.post("/login", c -> c.json(authService.login(c.body(LoginRequest.class))));
        r.post("/register", c -> c.json(authService.register(c.body(RegisterRequest.class))));
        return r;
    }
}
```

### 4.3 Repository Layer

```java
@Repository
public class UserRepository {
    private final DataSource dataSource;

    @Inject
    public UserRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public Optional<User> findByEmail(String email) {
        return Ax.query("SELECT * FROM users WHERE email = ?")
            .param(email)
            .mapTo(User.class)
            .findFirst();
    }
}
```

### 4.4 Application Entry Point

```java
public class Application {
    public static void main(String[] args) {
        Axiom.start(8080);  // Zero config!
    }
}
```

---

## 5. How It Works (Architecture)

### 5.1 Layer Diagram

```
┌─────────────────────────────────────────────────────┐
│                   User Code                          │
│  @Service, @Repository, @Routes + @Inject            │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│              Axiom DI Layer (Thin Wrapper)           │
│  - @Routes → auto-mount to App                       │
│  - @Repository → transaction awareness              │
│  - Config injection from AxiomConfig                 │
│  - Axiom.start() bootstrap                           │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│              Dagger 2 (Engine)                       │
│  - Dependency graph resolution                       │
│  - Compile-time code generation                      │
│  - Cycle detection                                   │
│  - Scope management                                  │
└─────────────────────────────────────────────────────┘
```

### 5.2 What Axiom Generates

Axiom's annotation processor generates a Dagger Module:

```java
// Generated by Axiom - wraps Dagger
@Module
public class AxiomModule {

    @Provides
    @Singleton
    DataSource provideDataSource() {
        return AxiomPersistence.getDataSource();
    }

    @Provides
    @Singleton
    JwtConfig provideJwtConfig() {
        return AxiomConfig.get(JwtConfig.class);
    }
}

@Component(modules = AxiomModule.class)
public interface AxiomComponent {
    AuthRoutes authRoutes();
    UserRoutes userRoutes();
}
```

### 5.3 Auto-Mount Generation

```java
// Generated by Axiom
public final class AxiomRoutesMounter {
    public static void mount(App app, AxiomComponent component) {
        app.route("/auth", component.authRoutes().router());
        app.route("/users", component.userRoutes().router());
    }
}
```

---

## 6. Complete Example

```java
// === Application.java ===
public class Application {
    public static void main(String[] args) {
        Axiom.start(8080);
    }
}

// === UserRepository.java ===
@Repository
public class UserRepository {
    private final DataSource dataSource;

    @Inject
    public UserRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public Optional<User> findByEmail(String email) {
        return Ax.query("SELECT * FROM users WHERE email = ?")
            .param(email)
            .mapTo(User.class)
            .findFirst();
    }

    public User save(User user) {
        return Ax.insert("users", user);
    }
}

// === JwtService.java ===
@Service
public class JwtService {
    private final JwtConfig config;

    @Inject
    public JwtService(JwtConfig config) {
        this.config = config;
    }

    public String generateToken(User user) {
        return JWT.create()
            .withSubject(user.id().toString())
            .withClaim("email", user.email())
            .sign(Algorithm.HMAC256(config.secret()));
    }

    public Optional<Long> validateToken(String token) {
        try {
            var decoded = JWT.require(Algorithm.HMAC256(config.secret()))
                .build()
                .verify(token);
            return Optional.of(Long.parseLong(decoded.getSubject()));
        } catch (Exception e) {
            return Optional.empty();
        }
    }
}

// === AuthService.java ===
@Service
public class AuthService {
    private final UserRepository userRepository;
    private final JwtService jwtService;

    @Inject
    public AuthService(UserRepository userRepository, JwtService jwtService) {
        this.userRepository = userRepository;
        this.jwtService = jwtService;
    }

    public AuthResponse login(LoginRequest request) {
        var user = userRepository.findByEmail(request.email())
            .orElseThrow(() -> new AuthException("Invalid credentials"));

        if (!BCrypt.verify(request.password(), user.passwordHash())) {
            throw new AuthException("Invalid credentials");
        }

        return new AuthResponse(jwtService.generateToken(user), user);
    }

    public User register(RegisterRequest request) {
        var passwordHash = BCrypt.hash(request.password());
        var user = new User(null, request.email(), request.name(), passwordHash);
        return userRepository.save(user);
    }
}

// === AuthRoutes.java ===
@Routes("/auth")
public class AuthRoutes {
    private final AuthService authService;

    @Inject
    public AuthRoutes(AuthService authService) {
        this.authService = authService;
    }

    public Router router() {
        Router r = new Router();
        r.post("/login", c -> c.json(authService.login(c.body(LoginRequest.class))));
        r.post("/register", c -> c.json(authService.register(c.body(RegisterRequest.class))));
        return r;
    }
}

// === UserRoutes.java ===
@Routes("/users")
public class UserRoutes {
    private final UserRepository userRepository;
    private final AuthMiddleware auth;

    @Inject
    public UserRoutes(UserRepository userRepository, AuthMiddleware auth) {
        this.userRepository = userRepository;
        this.auth = auth;
    }

    public Router router() {
        Router r = new Router();
        r.use(auth::requireAuth);
        r.get("/me", c -> c.json(c.get("user")));
        return r;
    }
}
```

---

## 7. Axiom Annotations (Our Layer)

| Annotation | Purpose | Maps To |
|------------|---------|---------|
| `@Service` | Business logic | Dagger `@Inject` |
| `@Repository` | Data access | Dagger `@Inject` + transaction-aware |
| `@Routes("/path")` | HTTP handlers | Dagger `@Inject` + auto-mount |
| `@Inject` | Constructor marker | Dagger `@Inject` (re-export) |

**Note**: We re-export `@Inject` from Dagger so users don't need direct Dagger dependency.

---

## 8. Circular Dependency Handling

Dagger detects cycles at compile time:

```
error: [Dagger/DependencyCycle] Found a dependency cycle:
    ServiceA is injected at
        ServiceB(serviceA)
    ServiceB is injected at
        ServiceC(serviceB)
    ServiceC is injected at
        ServiceA(serviceC)
```

### Solution: Lazy/Provider

```java
@Service
public class ServiceA {
    private final Provider<ServiceB> serviceB;  // Dagger's Lazy

    @Inject
    public ServiceA(Provider<ServiceB> serviceB) {
        this.serviceB = serviceB;
    }

    public void doWork() {
        serviceB.get().help();  // Resolved on first access
    }
}
```

---

## 9. Implementation Plan

### Phase 1: Foundation (Week 1-2)
- [ ] Add Dagger 2 dependency
- [ ] Create `@Service`, `@Repository`, `@Routes` annotations
- [ ] Create Axiom annotation processor that generates Dagger modules
- [ ] Implement `Axiom.start()` bootstrap

### Phase 2: Auto-Mount (Week 3)
- [ ] Implement `@Routes("/path")` scanning
- [ ] Generate route mounting code
- [ ] Test with example app

### Phase 3: Config Integration (Week 4)
- [ ] Config record injection from AxiomConfig
- [ ] DataSource injection from AxiomPersistence
- [ ] Documentation

---

## 10. Dependencies Added

```xml
<!-- pom.xml -->
<dependency>
    <groupId>com.google.dagger</groupId>
    <artifactId>dagger</artifactId>
    <version>2.51</version>
</dependency>
<dependency>
    <groupId>com.google.dagger</groupId>
    <artifactId>dagger-compiler</artifactId>
    <version>2.51</version>
    <scope>provided</scope>
</dependency>
```

---

## 11. What Users See vs What Happens

| User Writes | Axiom Generates | Dagger Handles |
|-------------|-----------------|----------------|
| `@Service` | `@Inject` on class | Dependency graph |
| `@Repository` | `@Inject` + markers | Instantiation |
| `@Routes("/path")` | Mount code | Wiring |
| `Axiom.start()` | Bootstrap code | Component creation |

---

## 12. Comparison: Before vs After

| Aspect | Before (Manual) | After (Axiom DI) |
|--------|-----------------|------------------|
| Application.java | 25+ lines | **5 lines** |
| Services wiring | Manual | **Auto (Dagger)** |
| Route registration | Manual | **Auto (@Routes)** |
| Config passing | Manual | **Auto** |
| Cycle detection | Runtime crash | **Compile error** |
| DI Engine | None/Custom | **Dagger 2 (battle-tested)** |

---

## 13. Non-Goals

- ❌ Building DI from scratch
- ❌ Runtime reflection
- ❌ Classpath scanning
- ❌ Field injection
- ❌ XML configuration
- ❌ Records for services (bad DX with many deps)

---

## 14. Decision

**Recommendation**: Approve.

**Key decisions:**
1. **Wrap Dagger 2** — don't reinvent DI
2. **Standard class pattern** — not records (clearer with many deps)
3. **`@Routes` auto-mounting** — Axiom's value-add
4. **Compile-time safety** — errors at build, not runtime

**Axiom DI = Dagger power + Axiom ergonomics + zero reinvention.**
