# RFC-0009: Runtime Adapter Contract

**Status:** Draft
**Type:** Core/Runtime
**Priority:** High
**Depends on:** RFC-0001, RFC-0007

---

## 1. Problem Statement

Axiom supports multiple HTTP server implementations:

- JDK HttpServer (built-in)
- Netty (high performance)
- Undertow (future)
- Others (future)

Without a clear adapter contract:

- Inconsistent behavior across runtimes
- Difficult to add new runtimes
- Core couples to runtime details
- Testing becomes complex

---

## 2. Design Goals

1. **Clear contract** — What adapters must implement
2. **Strict isolation** — Core knows nothing about runtime
3. **Consistent behavior** — Same API, different runtimes
4. **Testable** — Mock adapter for testing
5. **Extensible** — Easy to add new runtimes
6. **Performance-aware** — Adapter can optimize

---

## 3. Core Dependencies

```
axiom-core ────────────────> (nothing)
     ↑
axiom-http ────────────────> axiom-core
     ↑
axiom-runtime-* ───────────> axiom-core, axiom-http
```

**Critical Rule:** Core MUST NOT import any runtime module.

---

## 4. Server Interface

```java
package io.axiom.core.server;

/**
 * Contract for HTTP server implementations.
 * Each runtime adapter implements this interface.
 */
public interface Server {

    /**
     * Start the server with given configuration.
     * Binds to port and begins accepting connections.
     *
     * @throws StartupException if server cannot start
     */
    void start(ServerConfig config) throws StartupException;

    /**
     * Stop the server gracefully.
     * Stops accepting new connections, drains in-flight requests.
     *
     * @throws ShutdownException if shutdown fails
     */
    void stop() throws ShutdownException;

    /**
     * Force stop immediately without draining.
     */
    void forceStop();

    /**
     * The port server is listening on.
     * Returns -1 if not started.
     */
    int port();

    /**
     * Whether server is accepting requests.
     */
    boolean isRunning();

    /**
     * Set the handler for incoming requests.
     * Must be called before start().
     */
    void onRequest(Handler handler);
}
```

---

## 5. Server Configuration

```java
package io.axiom.core.server;

public record ServerConfig(
    int port,
    String host,
    int backlog,
    Duration readTimeout,
    Duration writeTimeout,
    Duration shutdownTimeout,
    Duration drainTimeout,
    boolean virtualThreads,
    int maxRequestSize,
    int maxHeaderSize
) {
    public static final int DEFAULT_PORT = 8080;
    public static final String DEFAULT_HOST = "0.0.0.0";
    public static final int DEFAULT_BACKLOG = 128;
    public static final Duration DEFAULT_READ_TIMEOUT = Duration.ofSeconds(30);
    public static final Duration DEFAULT_WRITE_TIMEOUT = Duration.ofSeconds(30);
    public static final Duration DEFAULT_SHUTDOWN_TIMEOUT = Duration.ofSeconds(30);
    public static final Duration DEFAULT_DRAIN_TIMEOUT = Duration.ofSeconds(10);
    public static final int DEFAULT_MAX_REQUEST_SIZE = 10 * 1024 * 1024; // 10MB
    public static final int DEFAULT_MAX_HEADER_SIZE = 8 * 1024; // 8KB

    public static ServerConfig defaults() {
        return new ServerConfig(
            DEFAULT_PORT,
            DEFAULT_HOST,
            DEFAULT_BACKLOG,
            DEFAULT_READ_TIMEOUT,
            DEFAULT_WRITE_TIMEOUT,
            DEFAULT_SHUTDOWN_TIMEOUT,
            DEFAULT_DRAIN_TIMEOUT,
            true,  // virtual threads by default
            DEFAULT_MAX_REQUEST_SIZE,
            DEFAULT_MAX_HEADER_SIZE
        );
    }

    public static Builder builder() {
        return new Builder();
    }

    public static final class Builder {
        // Builder implementation...
    }
}
```

---

## 6. Context Factory

Adapters create Context instances from native requests:

```java
package io.axiom.core.server;

/**
 * Factory for creating Context from native server request.
 * Each adapter implements this for its native types.
 */
public interface ContextFactory<NativeRequest, NativeResponse> {

    /**
     * Create a Context wrapping the native request/response.
     */
    Context create(NativeRequest request, NativeResponse response);
}
```

---

## 7. Adapter Implementation Pattern

### 7.1 JDK Adapter Example

```java
package io.axiom.runtime.jdk;

public final class JdkServer implements Server {

    private HttpServer httpServer;
    private Handler handler;
    private volatile boolean running;

    @Override
    public void start(ServerConfig config) throws StartupException {
        try {
            httpServer = HttpServer.create(
                new InetSocketAddress(config.host(), config.port()),
                config.backlog()
            );

            // Virtual thread executor
            if (config.virtualThreads()) {
                httpServer.setExecutor(
                    Executors.newVirtualThreadPerTaskExecutor()
                );
            }

            // Register handler
            httpServer.createContext("/", exchange -> {
                Context ctx = new JdkContext(exchange);
                try {
                    handler.handle(ctx);
                } catch (Exception e) {
                    handleError(ctx, e);
                } finally {
                    exchange.close();
                }
            });

            httpServer.start();
            running = true;

        } catch (IOException e) {
            throw new StartupException("Failed to start server", e);
        }
    }

    @Override
    public void stop() throws ShutdownException {
        if (httpServer != null) {
            httpServer.stop((int) config.drainTimeout().toSeconds());
            running = false;
        }
    }

    // ... other methods
}
```

### 7.2 JDK Context Example

```java
package io.axiom.runtime.jdk;

final class JdkContext implements Context {

    private final HttpExchange exchange;
    private final Map<String, String> params;
    private final Map<String, Object> state;
    private byte[] bodyCache;
    private boolean committed;
    private int statusCode = 200;

    JdkContext(HttpExchange exchange, Map<String, String> params) {
        this.exchange = exchange;
        this.params = params;
        this.state = new HashMap<>();
    }

    @Override
    public String method() {
        return exchange.getRequestMethod();
    }

    @Override
    public String path() {
        return exchange.getRequestURI().getPath();
    }

    @Override
    public String param(String name) {
        return params.get(name);
    }

    @Override
    public void status(int code) {
        if (committed) {
            throw new ResponseCommittedException();
        }
        this.statusCode = code;
    }

    @Override
    public void json(Object value) {
        if (committed) {
            throw new ResponseCommittedException();
        }

        byte[] body = jsonCodec.encode(value);
        exchange.getResponseHeaders().add("Content-Type", "application/json");
        exchange.sendResponseHeaders(statusCode, body.length);
        exchange.getResponseBody().write(body);
        committed = true;
    }

    // ... other methods
}
```

---

## 8. Adapter Responsibilities

Each adapter MUST:

| Responsibility | Description |
|----------------|-------------|
| Implement Server | Full Server interface |
| Create Context | Bridge native → Context |
| Handle lifecycle | Start/stop correctly |
| Virtual threads | Support if configured |
| Error propagation | Pass errors to handler |
| Request limits | Enforce size limits |
| Timeout handling | Implement read/write timeouts |
| Graceful shutdown | Drain requests properly |

Each adapter MUST NOT:

| Anti-pattern | Reason |
|--------------|--------|
| Reference other adapters | Independence |
| Add to core module | Circular dependency |
| Change core contracts | Stability |
| Swallow exceptions | Debugging |
| Block on shutdown | Responsiveness |

---

## 9. Thread Model Requirements

### 9.1 Virtual Threads (Default)

```java
// Adapter creates executor
ExecutorService executor = config.virtualThreads()
    ? Executors.newVirtualThreadPerTaskExecutor()
    : Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

// Each request on its own thread
executor.submit(() -> {
    Context ctx = createContext(request, response);
    handler.handle(ctx);
});
```

### 9.2 Thread Safety Contract

- Context is NOT thread-safe (request-scoped)
- One request = one thread
- User spawns threads at own risk
- Framework does not share Context

---

## 10. Request/Response Lifecycle

```
Native Request arrives
         │
         ▼
┌─────────────────────┐
│ Adapter receives    │
│ native request      │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ Create Context      │
│ (wrap native)       │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ Call handler.handle │
│ (on virtual thread) │
└──────────┬──────────┘
           │
     ┌─────┴─────┐
     │           │
  Success     Exception
     │           │
     ▼           ▼
┌─────────┐ ┌─────────────┐
│ Context │ │ Error       │
│ writes  │ │ handler     │
│ response│ │ writes      │
└────┬────┘ └──────┬──────┘
     │             │
     └──────┬──────┘
            │
            ▼
┌─────────────────────┐
│ Adapter flushes     │
│ native response     │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ Cleanup/close       │
└─────────────────────┘
```

---

## 11. Error Handling in Adapter

```java
// Adapter's request handling loop
void handleRequest(NativeRequest req, NativeResponse res) {
    Context ctx = createContext(req, res);

    try {
        handler.handle(ctx);
    } catch (Throwable e) {
        // Let framework error handler deal with it
        // Adapter should not catch and process errors
        errorHandler.handle(ctx, e);
    } finally {
        // Ensure response is flushed
        if (!ctx.isCommitted()) {
            // Send empty 200 if nothing written
            // Or let error handler deal with it
        }
        // Cleanup resources
        cleanup(req, res);
    }
}
```

---

## 12. Adapter Registration

Adapters are used via concrete App implementations:

```java
// User code
App app = new JdkApp();  // Uses JdkServer internally
app.route(router);
app.listen(8080);

// Or with config
App app = new JdkApp(ServerConfig.builder()
    .port(9090)
    .virtualThreads(true)
    .build());
```

No ServiceLoader, no classpath scanning.

---

## 13. Testing Adapter

Mock adapter for testing without network:

```java
package io.axiom.test;

public final class TestServer implements Server {

    private Handler handler;
    private boolean running;

    @Override
    public void start(ServerConfig config) {
        running = true;
    }

    @Override
    public void stop() {
        running = false;
    }

    /**
     * Simulate a request for testing.
     */
    public Context simulateRequest(String method, String path) {
        MockContext ctx = new MockContext(method, path);
        try {
            handler.handle(ctx);
        } catch (Exception e) {
            ctx.setError(e);
        }
        return ctx;
    }

    // ... other methods
}
```

---

## 14. Performance Expectations

| Metric | Minimum | Target |
|--------|---------|--------|
| Request overhead | < 1μs | < 500ns |
| Context creation | < 500ns | < 200ns |
| Response write | < 1μs | < 500ns |
| Throughput (hello) | 50K req/s | 100K+ req/s |

Adapters should benchmark and optimize.

---

## 15. Planned Adapters

| Adapter | Priority | Status | Notes |
|---------|----------|--------|-------|
| axiom-runtime-jdk | P0 | Planned | Default, JDK HttpServer |
| axiom-runtime-netty | P1 | Planned | High performance |
| axiom-runtime-undertow | P2 | Future | Alternative |
| axiom-runtime-helidon | P3 | Future | Experimental |

---

## 16. Non-Goals

- Adapter auto-discovery
- Runtime switching at runtime
- Adapter feature negotiation
- Adapter version compatibility matrix

---

## 17. Final Decision

- Server interface defines adapter contract
- ServerConfig for all configuration
- Context created by adapter from native
- Virtual threads by default
- Clear lifecycle integration
- Error handling delegated to framework

**Approved for implementation.**

---
